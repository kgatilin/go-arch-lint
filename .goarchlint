# Refreshed by go-arch-lint refresh with preset=simple
# Previous config backed up to .goarchlint.backup
# You can customize the error_prompt section to fit your project's needs

module: github.com/kgatilin/go-arch-lint
preset_used: simple
error_prompt:
  enabled: true
  architectural_goals: |4
        Simple Go architecture aims to:
        - Separate public APIs (pkg) from private implementation (internal)
        - Keep command-line entry points minimal and focused
        - Enable code reuse through public packages
        - Protect internal implementation details from external use
  principles:
    - cmd contains only application entry points and CLI logic
    - pkg contains public libraries that could be imported by other projects
    - internal contains private code that cannot be imported externally (Go compiler enforces this)
    - "Dependencies flow: cmd → pkg → internal"
    - internal packages should have zero dependencies on each other for maximum isolation
  refactoring_guidance: |4
        To refactor toward simple architecture compliance:

        1. **Consolidate entry points in cmd/**: Move main.go files and CLI setup to cmd/
        2. **Extract reusable code to pkg/**: Code that provides public APIs or could be used by other projects goes in pkg/
        3. **Move private implementation to internal/**: Implementation details, domain logic, and internal utilities belong in internal/
        4. **Break internal coupling**: If internal packages import each other:
           - Define interfaces in the importing package
           - Use adapters in pkg/ to bridge between internal packages
           - Consider if packages are too granular and should be merged

        Example refactoring:
        - Before: internal/users/service.go imports internal/database directly
        - After: internal/users/service.go defines UserRepository interface, pkg/app/app.go creates adapter, internal/database implements interface
  coverage_guidance: |4
        **Test Coverage Philosophy for Simple Architecture:**

        Coverage thresholds reflect the purpose of each layer:
        - **internal (70%)**: High coverage for private implementation. Core business logic and domain primitives should be thoroughly tested with unit tests.
        - **pkg (60%)**: Good coverage for public APIs. Test the public interface comprehensively since external consumers depend on it.
        - **cmd (30%)**: Basic coverage for entry points. Focus on integration tests that verify main workflows and flag parsing.

        **Why test coverage matters:**
        - Unit tests in internal/ ensure core logic is correct and maintainable
        - Integration tests in pkg/ verify public APIs work as documented
        - E2E tests in cmd/ validate the complete application flow
        - High coverage enables safe refactoring without breaking functionality

        **What to test:**
        - internal/: All core business logic, data structures, algorithms, validation
        - pkg/: Public API functions, error handling, interface contracts
        - cmd/: CLI flag parsing, command execution, basic end-to-end workflows
  blackbox_testing_guidance: |4
        **Why Blackbox Testing Matters:**

        Blackbox tests (using 'package foo_test' instead of 'package foo') verify behavior through the public API, making them more resilient to internal refactoring.

        - Tests should verify behavior through the public interface, not internal implementation details
        - If you can't test adequately through the public API, it may indicate design issues with your component's interface
        - Blackbox tests encourage better API design and reduce coupling between tests and implementation
        - When internals change, blackbox tests remain valid as long as the public contract is maintained

        **This is a Go best practice:** The standard library and most Go projects use blackbox tests (package foo_test) for package-level testing.

        **How to convert to blackbox testing:**
        1. Change package declaration from 'package foo' to 'package foo_test' in test files
        2. Import your package: import "your-module/path/to/foo"
        3. Test only through exported (capitalized) functions, types, and methods
        4. If you can't test adequately through the public API, consider whether your API design needs improvement
structure:
  required_directories:
    cmd: Application entry points
    internal: Private application code
    pkg: Public libraries and APIs
  allow_other_directories: true
rules:
  staticcheck: true
  directories_import:
    cmd:
      - pkg
    internal: []
    pkg:
      - internal
  detect_unused: true
  shared_external_imports:
    detect: true
    mode: warn
    exclusions:
      - fmt
      - strings
      - errors
      - time
      - context
      - gopkg.in/yaml.v3
    exclusion_patterns:
      - encoding/*
  test_files:
    lint: true
    exempt_imports:
      - testing
      - github.com/stretchr/testify/assert
      - github.com/stretchr/testify/require
      - github.com/stretchr/testify/mock
    location: colocated
    require_blackbox: true
  test_coverage:
    enabled: true
    threshold: 60
    package_thresholds:
      cmd: 0
      internal: 70
      pkg: 60
