# Refreshed by go-arch-lint refresh with preset=simple
# Previous config backed up to .goarchlint.backup
# You can customize the error_prompt section to fit your project's needs

module: github.com/kgatilin/go-arch-lint
preset_used: simple
error_prompt:
  enabled: true
  architectural_goals: |4
        Simple Go architecture aims to:
        - Separate public APIs (pkg) from private implementation (internal)
        - Keep command-line entry points minimal and focused
        - Enable code reuse through public packages
        - Protect internal implementation details from external use
  principles:
    - cmd contains only application entry points and CLI logic
    - pkg contains public libraries that could be imported by other projects
    - internal contains private code that cannot be imported externally (Go compiler enforces this)
    - "Dependencies flow: cmd → pkg → internal"
    - internal packages should have zero dependencies on each other for maximum isolation
  refactoring_guidance: |4
        To refactor toward simple architecture compliance:

        1. **Consolidate entry points in cmd/**: Move main.go files and CLI setup to cmd/
        2. **Extract reusable code to pkg/**: Code that provides public APIs or could be used by other projects goes in pkg/
        3. **Move private implementation to internal/**: Implementation details, domain logic, and internal utilities belong in internal/
        4. **Break internal coupling**: If internal packages import each other:
           - Define interfaces in the importing package
           - Use adapters in pkg/ to bridge between internal packages
           - Consider if packages are too granular and should be merged

        Example refactoring:
        - Before: internal/users/service.go imports internal/database directly
        - After: internal/users/service.go defines UserRepository interface, pkg/app/app.go creates adapter, internal/database implements interface
  coverage_guidance: |4
        **Test Coverage Philosophy for Simple Architecture:**

        Coverage thresholds reflect the purpose of each layer:
        - **internal (70%)**: High coverage for private implementation. Core business logic and domain primitives should be thoroughly tested with unit tests.
        - **pkg (60%)**: Good coverage for public APIs. Test the public interface comprehensively since external consumers depend on it.
        - **cmd (30%)**: Basic coverage for entry points. Focus on integration tests that verify main workflows and flag parsing.

        **Why test coverage matters:**
        - Unit tests in internal/ ensure core logic is correct and maintainable
        - Integration tests in pkg/ verify public APIs work as documented
        - E2E tests in cmd/ validate the complete application flow
        - High coverage enables safe refactoring without breaking functionality

        **What to test:**
        - internal/: All core business logic, data structures, algorithms, validation
        - pkg/: Public API functions, error handling, interface contracts
        - cmd/: CLI flag parsing, command execution, basic end-to-end workflows
structure:
  required_directories:
    cmd: Application entry points
    internal: Private application code
    pkg: Public libraries and APIs
  allow_other_directories: true
rules:
  directories_import:
    cmd:
      - pkg
    internal: []
    pkg:
      - internal
  detect_unused: true
  shared_external_imports:
    detect: true
    mode: warn
    exclusions:
      - fmt
      - strings
      - errors
      - time
      - context
    exclusion_patterns:
      - encoding/*
  test_files:
    lint: true
    exempt_imports:
      - testing
      - github.com/stretchr/testify/assert
      - github.com/stretchr/testify/require
      - github.com/stretchr/testify/mock
    location: colocated
    require_blackbox: true
  test_coverage:
    enabled: true
    threshold: 70
    package_thresholds:
      cmd: 30
      internal: 80
      pkg: 70
