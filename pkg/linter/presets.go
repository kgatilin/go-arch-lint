package linter

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

// Preset represents a predefined project structure template
type Preset struct {
	Name        string
	Description string
	Config      PresetConfig
}

// PresetConfig mirrors the config structure for YAML generation
type PresetConfig struct {
	Structure PresetStructure           `yaml:"structure"`
	Rules     PresetRules               `yaml:"rules"`
}

type PresetStructure struct {
	RequiredDirectories   map[string]string `yaml:"required_directories"`
	AllowOtherDirectories bool              `yaml:"allow_other_directories"`
}

type PresetRules struct {
	DirectoriesImport map[string][]string `yaml:"directories_import"`
	DetectUnused      bool                `yaml:"detect_unused"`
}

// AvailablePresets returns all available presets
func AvailablePresets() []Preset {
	return []Preset{
		{
			Name:        "ddd",
			Description: "Domain-Driven Design with strict layering (domain → app → infra)",
			Config: PresetConfig{
				Structure: PresetStructure{
					RequiredDirectories: map[string]string{
						"internal/domain": "Core business logic, entities, value objects, domain services",
						"internal/app":    "Application services, use cases, orchestration",
						"internal/infra":  "Infrastructure implementations (DB, external APIs, messaging)",
						"cmd":             "Application entry points",
					},
					AllowOtherDirectories: true,
				},
				Rules: PresetRules{
					DirectoriesImport: map[string][]string{
						"internal/domain": {},
						"internal/app":    {"internal/domain"},
						"internal/infra":  {"internal/domain"},
						"cmd":             {"internal/app", "internal/infra"},
					},
					DetectUnused: true,
				},
			},
		},
		{
			Name:        "simple",
			Description: "Basic Go project structure (cmd → pkg → internal)",
			Config: PresetConfig{
				Structure: PresetStructure{
					RequiredDirectories: map[string]string{
						"cmd":      "Application entry points",
						"pkg":      "Public libraries and APIs",
						"internal": "Private application code",
					},
					AllowOtherDirectories: true,
				},
				Rules: PresetRules{
					DirectoriesImport: map[string][]string{
						"cmd":      {"pkg"},
						"pkg":      {"internal"},
						"internal": {},
					},
					DetectUnused: true,
				},
			},
		},
		{
			Name:        "hexagonal",
			Description: "Ports & Adapters architecture (core → ports → adapters)",
			Config: PresetConfig{
				Structure: PresetStructure{
					RequiredDirectories: map[string]string{
						"internal/core":     "Business logic and domain models",
						"internal/ports":    "Interface definitions (inbound/outbound)",
						"internal/adapters": "Concrete implementations of ports",
						"cmd":               "Application entry points",
					},
					AllowOtherDirectories: true,
				},
				Rules: PresetRules{
					DirectoriesImport: map[string][]string{
						"internal/core":     {},
						"internal/ports":    {"internal/core"},
						"internal/adapters": {"internal/ports", "internal/core"},
						"cmd":               {"internal/ports", "internal/adapters"},
					},
					DetectUnused: true,
				},
			},
		},
	}
}

// GetPreset returns a preset by name
func GetPreset(name string) (*Preset, error) {
	for _, preset := range AvailablePresets() {
		if preset.Name == name {
			return &preset, nil
		}
	}
	return nil, fmt.Errorf("preset '%s' not found", name)
}

// CreateConfigFromPreset generates a .goarchlint file from a preset
func CreateConfigFromPreset(projectPath, presetName string, createDirs bool) error {
	preset, err := GetPreset(presetName)
	if err != nil {
		return err
	}

	// Detect module from go.mod
	module, err := detectModuleFromGoMod(projectPath)
	if err != nil {
		return fmt.Errorf("detecting module: %w", err)
	}

	// Create full config with module
	configContent := fmt.Sprintf("# Auto-generated by go-arch-lint init --preset=%s\n\n", presetName)
	configContent += fmt.Sprintf("module: %s\n\n", module)

	// Marshal preset config to YAML
	yamlData, err := yaml.Marshal(preset.Config)
	if err != nil {
		return fmt.Errorf("marshaling config: %w", err)
	}

	configContent += string(yamlData)

	// Write .goarchlint file
	configPath := filepath.Join(projectPath, ".goarchlint")
	if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
		return fmt.Errorf("writing config file: %w", err)
	}

	// Create directories if requested
	if createDirs {
		for dirPath := range preset.Config.Structure.RequiredDirectories {
			fullPath := filepath.Join(projectPath, dirPath)
			if err := os.MkdirAll(fullPath, 0755); err != nil {
				return fmt.Errorf("creating directory %s: %w", dirPath, err)
			}
		}
	}

	return nil
}

func detectModuleFromGoMod(projectPath string) (string, error) {
	goModPath := filepath.Join(projectPath, "go.mod")
	data, err := os.ReadFile(goModPath)
	if err != nil {
		return "", fmt.Errorf("reading go.mod: %w", err)
	}

	// Simple parsing - look for "module <name>" line
	lines := string(data)
	for i := 0; i < len(lines); {
		end := i
		for end < len(lines) && lines[end] != '\n' {
			end++
		}
		line := lines[i:end]

		if len(line) > 7 && line[:7] == "module " {
			return line[7:], nil
		}

		i = end + 1
	}

	return "", fmt.Errorf("module not found in go.mod")
}
