package output

import (
	"fmt"
	"strings"
	"time"
)

// StructureInfo represents the structure configuration for documentation
type StructureInfo struct {
	RequiredDirectories   map[string]string
	AllowOtherDirectories bool
	ExistingDirs          map[string]bool // Track which dirs actually exist
}

// RulesInfo represents the architectural rules configuration
type RulesInfo struct {
	DirectoriesImport map[string][]string
	DetectUnused      bool
}

// FullDocumentation contains all information for comprehensive documentation
type FullDocumentation struct {
	Structure      StructureInfo
	Rules          RulesInfo
	Graph          Graph
	Files          []FileWithAPI
	Violations     []Violation
	ViolationCount int
	FileCount      int
	PackageCount   int
}

// GenerateFullDocumentation creates a comprehensive markdown document
func GenerateFullDocumentation(doc FullDocumentation) string {
	var sb strings.Builder

	// Header
	sb.WriteString("# Project Architecture\n\n")
	sb.WriteString(fmt.Sprintf("**Generated by go-arch-lint on %s**\n\n", time.Now().Format("2006-01-02")))

	// Table of Contents
	sb.WriteString("## Table of Contents\n")
	sb.WriteString("- [Project Structure](#project-structure)\n")
	sb.WriteString("- [Architectural Rules](#architectural-rules)\n")
	sb.WriteString("- [Dependency Graph](#dependency-graph)\n")
	sb.WriteString("- [Public API](#public-api)\n")
	sb.WriteString("- [Statistics](#statistics)\n")
	sb.WriteString("\n---\n\n")

	// Project Structure Section
	sb.WriteString("## Project Structure\n\n")
	if len(doc.Structure.RequiredDirectories) > 0 {
		sb.WriteString("Required directories as defined in `.goarchlint`:\n\n")

		for dirPath, description := range doc.Structure.RequiredDirectories {
			sb.WriteString(fmt.Sprintf("### %s\n", dirPath))
			sb.WriteString(fmt.Sprintf("**Purpose**: %s\n\n", description))

			// Show allowed dependencies from rules
			if allowed, exists := doc.Rules.DirectoriesImport[dirPath]; exists {
				if len(allowed) == 0 {
					sb.WriteString("**Allowed dependencies**: None (isolated layer)\n\n")
				} else {
					sb.WriteString(fmt.Sprintf("**Allowed dependencies**: %s\n\n", strings.Join(allowed, ", ")))
				}
			}

			// Show existence status
			if exists, ok := doc.Structure.ExistingDirs[dirPath]; ok && exists {
				sb.WriteString("**Status**: ✓ Exists\n\n")
			} else {
				sb.WriteString("**Status**: ✗ Missing\n\n")
			}

			sb.WriteString("---\n\n")
		}

		if !doc.Structure.AllowOtherDirectories {
			sb.WriteString("**Strict Mode**: Only required directories are allowed (allow_other_directories: false)\n\n")
		}
	} else {
		sb.WriteString("No required directory structure defined in `.goarchlint`.\n\n")
	}

	sb.WriteString("---\n\n")

	// Architectural Rules Section
	sb.WriteString("## Architectural Rules\n\n")
	sb.WriteString("From `.goarchlint`:\n\n")
	sb.WriteString("```yaml\n")

	// Show structure rules if defined
	if len(doc.Structure.RequiredDirectories) > 0 {
		sb.WriteString("structure:\n")
		sb.WriteString("  required_directories:\n")
		for dirPath, description := range doc.Structure.RequiredDirectories {
			sb.WriteString(fmt.Sprintf("    %s: \"%s\"\n", dirPath, description))
		}
		sb.WriteString(fmt.Sprintf("  allow_other_directories: %t\n\n", doc.Structure.AllowOtherDirectories))
	}

	// Show import rules
	sb.WriteString("rules:\n")
	sb.WriteString("  directories_import:\n")
	for dir, allowed := range doc.Rules.DirectoriesImport {
		if len(allowed) == 0 {
			sb.WriteString(fmt.Sprintf("    %s: []\n", dir))
		} else {
			sb.WriteString(fmt.Sprintf("    %s: [%s]\n", dir, strings.Join(allowed, ", ")))
		}
	}
	sb.WriteString(fmt.Sprintf("  detect_unused: %t\n", doc.Rules.DetectUnused))
	sb.WriteString("```\n\n")

	// Validation Status
	if doc.ViolationCount == 0 {
		sb.WriteString("**Validation Status**: ✓ No violations found\n\n")
	} else {
		sb.WriteString(fmt.Sprintf("**Validation Status**: ✗ %d violation(s) found (see stderr output)\n\n", doc.ViolationCount))
	}

	sb.WriteString("---\n\n")

	// Dependency Graph Section
	sb.WriteString("## Dependency Graph\n\n")
	sb.WriteString("Detailed method-level dependencies between files:\n\n")

	for _, node := range doc.Graph.GetNodes() {
		sb.WriteString(fmt.Sprintf("### %s\n", node.GetRelPath()))
		sb.WriteString(fmt.Sprintf("**Package**: %s\n\n", node.GetPackage()))

		// Collect local and external dependencies separately
		var localDeps []Dependency
		var externalDeps []Dependency

		for _, dep := range node.GetDependencies() {
			if dep.IsLocalDep() {
				localDeps = append(localDeps, dep)
			} else {
				externalDeps = append(externalDeps, dep)
			}
		}

		// Show local dependencies
		if len(localDeps) > 0 {
			sb.WriteString("**Local Dependencies**:\n")
			for _, dep := range localDeps {
				sb.WriteString(fmt.Sprintf("- %s\n", dep.GetLocalPath()))
				usedSymbols := dep.GetUsedSymbols()
				if len(usedSymbols) > 0 {
					for _, symbol := range usedSymbols {
						sb.WriteString(fmt.Sprintf("  - %s\n", symbol))
					}
				}
			}
			sb.WriteString("\n")
		} else {
			sb.WriteString("**Local Dependencies**: None\n\n")
		}

		// Show external dependencies
		if len(externalDeps) > 0 {
			sb.WriteString("**External Dependencies**:\n")
			for _, dep := range externalDeps {
				sb.WriteString(fmt.Sprintf("- %s\n", dep.GetImportPath()))
				usedSymbols := dep.GetUsedSymbols()
				if len(usedSymbols) > 0 {
					for _, symbol := range usedSymbols {
						sb.WriteString(fmt.Sprintf("  - %s\n", symbol))
					}
				}
			}
			sb.WriteString("\n")
		} else {
			sb.WriteString("**External Dependencies**: None\n\n")
		}

		sb.WriteString("---\n\n")
	}

	// Public API Section
	sb.WriteString("## Public API\n\n")
	sb.WriteString("Exported interfaces and types available for consumption:\n\n")

	if len(doc.Files) == 0 {
		sb.WriteString("No public API exported.\n\n")
	} else {
		// Group files by package
		packageFiles := make(map[string][]FileWithAPI)
		for _, file := range doc.Files {
			pkg := file.GetPackage()
			packageFiles[pkg] = append(packageFiles[pkg], file)
		}

		for pkgName, files := range packageFiles {
			sb.WriteString(fmt.Sprintf("### %s\n\n", pkgName))

			for _, file := range files {
				decls := file.GetExportedDecls()
				if len(decls) == 0 {
					continue
				}

				// Group declarations by kind
				types := []ExportedDecl{}
				functions := []ExportedDecl{}

				for _, decl := range decls {
					if decl.GetKind() == "Function" {
						functions = append(functions, decl)
					} else {
						types = append(types, decl)
					}
				}

				// Output types
				if len(types) > 0 {
					sb.WriteString("#### Types\n\n")
					for _, decl := range types {
						sb.WriteString(fmt.Sprintf("**%s**", decl.GetName()))
						if decl.GetSignature() != "" {
							sb.WriteString(fmt.Sprintf(" `%s`", decl.GetSignature()))
						}
						sb.WriteString("\n")

						props := decl.GetProperties()
						if len(props) > 0 {
							sb.WriteString("- Properties:\n")
							for _, prop := range props {
								sb.WriteString(fmt.Sprintf("  - %s\n", prop))
							}
						}
						sb.WriteString("\n")
					}
				}

				// Output functions
				if len(functions) > 0 {
					sb.WriteString("#### Package Functions\n\n")
					for _, decl := range functions {
						sb.WriteString(fmt.Sprintf("- `%s`\n", decl.GetSignature()))
					}
					sb.WriteString("\n")
				}
			}

			sb.WriteString("---\n\n")
		}
	}

	// Statistics Section
	sb.WriteString("## Statistics\n\n")
	sb.WriteString(fmt.Sprintf("- **Total Files**: %d\n", doc.FileCount))
	sb.WriteString(fmt.Sprintf("- **Total Packages**: %d\n", doc.PackageCount))
	if len(doc.Structure.RequiredDirectories) > 0 {
		existingCount := 0
		for _, exists := range doc.Structure.ExistingDirs {
			if exists {
				existingCount++
			}
		}
		sb.WriteString(fmt.Sprintf("- **Required Directories**: %d/%d present\n", existingCount, len(doc.Structure.RequiredDirectories)))
	}
	sb.WriteString(fmt.Sprintf("- **Violations**: %d\n", doc.ViolationCount))

	// Count external dependencies
	externalDepsSet := make(map[string]bool)
	for _, node := range doc.Graph.GetNodes() {
		for _, dep := range node.GetDependencies() {
			if !dep.IsLocalDep() {
				externalDepsSet[dep.GetImportPath()] = true
			}
		}
	}
	sb.WriteString(fmt.Sprintf("- **External Dependencies**: %d\n", len(externalDepsSet)))

	sb.WriteString("\n---\n\n")
	sb.WriteString("*This documentation is auto-generated. To regenerate: `go-arch-lint -format=full .` or `go-arch-lint -format=docs .`*\n")

	return sb.String()
}
