package output

import (
	"fmt"
	"sort"
	"strings"
	"time"
)

// PackageIndexInfo contains summary information about a package
type PackageIndexInfo struct {
	Name         string
	Path         string   // Directory path for the package (e.g., "pkg/linter")
	FileCount    int
	ExportCount  int
	KeyExports   []string // Top 3-4 important types/functions
	Dependencies []string // Just package names
}

// LayerPackages organizes packages by architectural layer
type LayerPackages struct {
	CmdPackages      []PackageIndexInfo
	PkgPackages      []PackageIndexInfo
	InternalPackages []PackageIndexInfo
}

// GenerateIndexDocumentation creates a lightweight architecture index
func GenerateIndexDocumentation(doc FullDocumentation) string {
	var sb strings.Builder

	// Header
	sb.WriteString("# Project Architecture Index\n\n")
	sb.WriteString(fmt.Sprintf("**Generated by go-arch-lint on %s**\n\n", time.Now().Format("2006-01-02")))
	sb.WriteString("*Quick architecture reference. Use package-specific Details commands for comprehensive information.*\n\n")

	// Quick Reference
	sb.WriteString("## Quick Reference\n\n")
	statusStr := "✓ 0 violations"
	if doc.ViolationCount > 0 {
		statusStr = fmt.Sprintf("✗ %d violation(s)", doc.ViolationCount)
	}
	sb.WriteString("- **Module**: (detected from go.mod)\n")
	sb.WriteString(fmt.Sprintf("- **Status**: %s\n", statusStr))
	sb.WriteString(fmt.Sprintf("- **Packages**: %d\n", doc.PackageCount))
	sb.WriteString(fmt.Sprintf("- **Files**: %d\n\n", doc.FileCount))

	// Architecture Summary
	sb.WriteString("## Architecture Summary\n\n")
	if len(doc.Structure.RequiredDirectories) > 0 {
		sb.WriteString("Project uses strict layered architecture:\n\n")
		for dirPath, description := range doc.Structure.RequiredDirectories {
			if allowed, exists := doc.Rules.DirectoriesImport[dirPath]; exists {
				allowedStr := "none (isolated)"
				if len(allowed) > 0 {
					allowedStr = strings.Join(allowed, ", ")
				}
				sb.WriteString(fmt.Sprintf("- **%s** - %s (imports: %s)\n", dirPath, description, allowedStr))
			}
		}
		sb.WriteString("\n")
	}

	// Architectural Rules (CRITICAL per mentor feedback)
	sb.WriteString("## Architectural Rules\n\n")
	sb.WriteString("**Layer Dependencies:**\n\n")
	for dir, allowed := range doc.Rules.DirectoriesImport {
		if len(allowed) == 0 {
			sb.WriteString(fmt.Sprintf("- `%s` → `[]` (complete isolation)\n", dir))
		} else {
			sb.WriteString(fmt.Sprintf("- `%s` → `[%s]`\n", dir, strings.Join(allowed, ", ")))
		}
	}
	sb.WriteString("\n")

	if !doc.Structure.AllowOtherDirectories {
		sb.WriteString("**Strict Mode**: Only required directories are allowed\n\n")
	}

	// Build package index by layer
	packagesByLayer := buildPackagesByLayer(doc.Files)

	// Package Directory
	sb.WriteString("## Package Directory\n\n")

	if len(packagesByLayer.CmdPackages) > 0 {
		sb.WriteString("### cmd (Application Entry Points)\n\n")
		for _, pkg := range packagesByLayer.CmdPackages {
			formatPackageEntry(&sb, pkg)
		}
		sb.WriteString("\n")
	}

	if len(packagesByLayer.PkgPackages) > 0 {
		sb.WriteString("### pkg (Public APIs)\n\n")
		for _, pkg := range packagesByLayer.PkgPackages {
			formatPackageEntry(&sb, pkg)
		}
		sb.WriteString("\n")
	}

	if len(packagesByLayer.InternalPackages) > 0 {
		sb.WriteString("### internal (Isolated Primitives)\n\n")
		for _, pkg := range packagesByLayer.InternalPackages {
			formatPackageEntry(&sb, pkg)
		}
		sb.WriteString("\n")
	}

	// Agent Guidance
	sb.WriteString("## Agent Guidance\n\n")
	sb.WriteString("To get detailed information about specific packages:\n\n")
	sb.WriteString("**Per-package details**:\n")
	sb.WriteString("- Each package above has a **Details** command to get full information\n")
	sb.WriteString("- Example: `go-arch-lint -format=package pkg/linter`\n")
	sb.WriteString("- Shows: full API, dependencies, exported types/functions for that package\n\n")
	sb.WriteString("**Project-wide information**:\n")
	sb.WriteString("- Public API for all packages: `./go-arch-lint -format=api .`\n")
	sb.WriteString("- Dependency graph: `./go-arch-lint -format=markdown .`\n")
	sb.WriteString("- Method-level dependencies: `./go-arch-lint -detailed -format=markdown .`\n")
	sb.WriteString("- Check violations: `./go-arch-lint .`\n\n")
	sb.WriteString("**Common workflows**:\n")
	sb.WriteString("- Understanding a package → Find it below, run the Details command\n")
	sb.WriteString("- Adding new feature → Review architectural rules above, check layer constraints\n")
	sb.WriteString("- Checking violations → Run `./go-arch-lint .` to see current issues with guidance\n\n")

	// Statistics
	sb.WriteString("## Statistics\n\n")
	sb.WriteString(fmt.Sprintf("- **Total Files**: %d\n", doc.FileCount))
	sb.WriteString(fmt.Sprintf("- **Total Packages**: %d\n", doc.PackageCount))
	sb.WriteString(fmt.Sprintf("- **Violations**: %d\n", doc.ViolationCount))

	// Count external dependencies
	externalDepsSet := make(map[string]bool)
	for _, node := range doc.Graph.GetNodes() {
		for _, dep := range node.GetDependencies() {
			if !dep.IsLocalDep() {
				externalDepsSet[dep.GetImportPath()] = true
			}
		}
	}
	sb.WriteString(fmt.Sprintf("- **External Dependencies**: %d\n\n", len(externalDepsSet)))

	sb.WriteString("---\n\n")
	sb.WriteString("*Use the package-specific Details commands above to get comprehensive information about each package.*\n")
	sb.WriteString("*Run `./go-arch-lint docs` to regenerate this index.*\n")

	return sb.String()
}

// buildPackagesByLayer organizes packages by architectural layer
func buildPackagesByLayer(files []FileWithAPI) LayerPackages {
	packageMap := make(map[string]*PackageIndexInfo)

	// Build package information from files
	for _, file := range files {
		pkgName := file.GetPackage()
		relPath := file.GetRelPath()
		if pkgName == "" {
			continue
		}

		// Extract directory path from file path (e.g., "pkg/linter/linter.go" → "pkg/linter")
		pkgPath := relPath
		if idx := strings.LastIndex(relPath, "/"); idx >= 0 {
			pkgPath = relPath[:idx]
		} else {
			// File in root directory
			pkgPath = "."
		}

		// Use package path as the key to group files by directory
		if _, exists := packageMap[pkgPath]; !exists {
			packageMap[pkgPath] = &PackageIndexInfo{
				Name:         pkgName,
				Path:         pkgPath,
				KeyExports:   []string{},
				Dependencies: []string{},
			}
		}

		pkg := packageMap[pkgPath]
		pkg.FileCount++

		// Skip test files when collecting exports
		isTestFile := strings.HasSuffix(relPath, "_test.go")

		// Collect unique key exports (types and important functions)
		for _, decl := range file.GetExportedDecls() {
			isTestExport := strings.HasPrefix(decl.GetName(), "Test") || strings.HasPrefix(decl.GetName(), "Benchmark")

			// Only count non-test exports
			if !isTestFile && !isTestExport {
				pkg.ExportCount++

				// Keep first 3 exports as key exports
				if len(pkg.KeyExports) < 3 {
					pkg.KeyExports = append(pkg.KeyExports, decl.GetName())
				}
			}
		}
	}

	// Organize by layer (using Path not Name)
	result := LayerPackages{
		CmdPackages:      []PackageIndexInfo{},
		PkgPackages:      []PackageIndexInfo{},
		InternalPackages: []PackageIndexInfo{},
	}

	pkgPaths := make([]string, 0, len(packageMap))
	for path := range packageMap {
		pkgPaths = append(pkgPaths, path)
	}
	sort.Strings(pkgPaths)

	for _, path := range pkgPaths {
		pkg := packageMap[path]
		if strings.HasPrefix(path, "cmd") {
			result.CmdPackages = append(result.CmdPackages, *pkg)
		} else if strings.HasPrefix(path, "pkg") {
			result.PkgPackages = append(result.PkgPackages, *pkg)
		} else if strings.HasPrefix(path, "internal") {
			result.InternalPackages = append(result.InternalPackages, *pkg)
		}
	}

	// Sort each layer by path
	sort.Slice(result.CmdPackages, func(i, j int) bool {
		return result.CmdPackages[i].Path < result.CmdPackages[j].Path
	})
	sort.Slice(result.PkgPackages, func(i, j int) bool {
		return result.PkgPackages[i].Path < result.PkgPackages[j].Path
	})
	sort.Slice(result.InternalPackages, func(i, j int) bool {
		return result.InternalPackages[i].Path < result.InternalPackages[j].Path
	})

	return result
}

// formatPackageEntry formats a single package entry in the index
func formatPackageEntry(sb *strings.Builder, pkg PackageIndexInfo) {
	// Package name and path
	sb.WriteString(fmt.Sprintf("- **%s** (`%s`)\n", pkg.Name, pkg.Path))
	sb.WriteString(fmt.Sprintf("  - Files: %d | Exports: %d\n", pkg.FileCount, pkg.ExportCount))

	// Key exports
	if len(pkg.KeyExports) > 0 {
		sb.WriteString(fmt.Sprintf("  - Key exports: %s\n", strings.Join(pkg.KeyExports, ", ")))
	}

	// Command to get detailed info
	sb.WriteString(fmt.Sprintf("  - **Details**: `go-arch-lint -format=package %s`\n", pkg.Path))

	sb.WriteString("\n")
}
