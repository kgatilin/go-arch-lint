package output

import (
	"fmt"
	"sort"
	"strings"
	"time"
)

// PackageIndexInfo contains summary information about a package
type PackageIndexInfo struct {
	Name         string
	FileCount    int
	ExportCount  int
	KeyExports   []string // Top 3-4 important types/functions
	Dependencies []string // Just package names
}

// LayerPackages organizes packages by architectural layer
type LayerPackages struct {
	CmdPackages      []PackageIndexInfo
	PkgPackages      []PackageIndexInfo
	InternalPackages []PackageIndexInfo
}

// GenerateIndexDocumentation creates a lightweight architecture index
func GenerateIndexDocumentation(doc FullDocumentation) string {
	var sb strings.Builder

	// Header
	sb.WriteString("# Project Architecture Index\n\n")
	sb.WriteString(fmt.Sprintf("**Generated by go-arch-lint on %s**\n\n", time.Now().Format("2006-01-02")))
	sb.WriteString("*Lightweight reference for quick architecture understanding. See `docs/arch-generated.md` for detailed documentation.*\n\n")

	// Quick Reference
	sb.WriteString("## Quick Reference\n\n")
	statusStr := "✓ 0 violations"
	if doc.ViolationCount > 0 {
		statusStr = fmt.Sprintf("✗ %d violation(s)", doc.ViolationCount)
	}
	sb.WriteString("- **Module**: (detected from go.mod)\n")
	sb.WriteString(fmt.Sprintf("- **Status**: %s\n", statusStr))
	sb.WriteString(fmt.Sprintf("- **Packages**: %d\n", doc.PackageCount))
	sb.WriteString(fmt.Sprintf("- **Files**: %d\n\n", doc.FileCount))

	// Architecture Summary
	sb.WriteString("## Architecture Summary\n\n")
	if len(doc.Structure.RequiredDirectories) > 0 {
		sb.WriteString("Project uses strict layered architecture:\n\n")
		for dirPath, description := range doc.Structure.RequiredDirectories {
			if allowed, exists := doc.Rules.DirectoriesImport[dirPath]; exists {
				allowedStr := "none (isolated)"
				if len(allowed) > 0 {
					allowedStr = strings.Join(allowed, ", ")
				}
				sb.WriteString(fmt.Sprintf("- **%s** - %s (imports: %s)\n", dirPath, description, allowedStr))
			}
		}
		sb.WriteString("\n")
	}

	// Architectural Rules (CRITICAL per mentor feedback)
	sb.WriteString("## Architectural Rules\n\n")
	sb.WriteString("**Layer Dependencies:**\n\n")
	for dir, allowed := range doc.Rules.DirectoriesImport {
		if len(allowed) == 0 {
			sb.WriteString(fmt.Sprintf("- `%s` → `[]` (complete isolation)\n", dir))
		} else {
			sb.WriteString(fmt.Sprintf("- `%s` → `[%s]`\n", dir, strings.Join(allowed, ", ")))
		}
	}
	sb.WriteString("\n")

	if !doc.Structure.AllowOtherDirectories {
		sb.WriteString("**Strict Mode**: Only required directories are allowed\n\n")
	}

	// Build package index by layer
	packagesByLayer := buildPackagesByLayer(doc.Files)

	// Package Directory
	sb.WriteString("## Package Directory\n\n")

	if len(packagesByLayer.CmdPackages) > 0 {
		sb.WriteString("### cmd (Application Entry Points)\n\n")
		for _, pkg := range packagesByLayer.CmdPackages {
			formatPackageEntry(&sb, pkg)
		}
		sb.WriteString("\n")
	}

	if len(packagesByLayer.PkgPackages) > 0 {
		sb.WriteString("### pkg (Public APIs)\n\n")
		for _, pkg := range packagesByLayer.PkgPackages {
			formatPackageEntry(&sb, pkg)
		}
		sb.WriteString("\n")
	}

	if len(packagesByLayer.InternalPackages) > 0 {
		sb.WriteString("### internal (Isolated Primitives)\n\n")
		for _, pkg := range packagesByLayer.InternalPackages {
			formatPackageEntry(&sb, pkg)
		}
		sb.WriteString("\n")
	}

	// Agent Guidance
	sb.WriteString("## Agent Guidance\n\n")
	sb.WriteString("To get more detailed information when needed:\n\n")
	sb.WriteString("**Quick explorations**:\n")
	sb.WriteString("- Public API signatures: `./go-arch-lint -format=api .`\n")
	sb.WriteString("- Dependency graph: `./go-arch-lint -format=markdown .`\n")
	sb.WriteString("- Method-level details: `./go-arch-lint -detailed -format=markdown .`\n\n")
	sb.WriteString("**Comprehensive documentation**:\n")
	sb.WriteString("- Load `docs/arch-generated.md` for complete architecture with full dependency graph and public API\n")
	sb.WriteString("- Run `./go-arch-lint docs` to regenerate both index and full documentation\n\n")
	sb.WriteString("**Common workflows**:\n")
	sb.WriteString("- Understanding a package → Find it below, check exports and dependencies\n")
	sb.WriteString("- Adding new feature → Review architectural rules above, check layer constraints\n")
	sb.WriteString("- Checking violations → Run `./go-arch-lint .` to see current issues with guidance\n\n")

	// Statistics
	sb.WriteString("## Statistics\n\n")
	sb.WriteString(fmt.Sprintf("- **Total Files**: %d\n", doc.FileCount))
	sb.WriteString(fmt.Sprintf("- **Total Packages**: %d\n", doc.PackageCount))
	sb.WriteString(fmt.Sprintf("- **Violations**: %d\n", doc.ViolationCount))

	// Count external dependencies
	externalDepsSet := make(map[string]bool)
	for _, node := range doc.Graph.GetNodes() {
		for _, dep := range node.GetDependencies() {
			if !dep.IsLocalDep() {
				externalDepsSet[dep.GetImportPath()] = true
			}
		}
	}
	sb.WriteString(fmt.Sprintf("- **External Dependencies**: %d\n\n", len(externalDepsSet)))

	sb.WriteString("---\n\n")
	sb.WriteString("*This is a lightweight index. For complete documentation with method-level dependencies and full public API,*\n")
	sb.WriteString("*load `docs/arch-generated.md` or run `./go-arch-lint -format=full .`*\n")

	return sb.String()
}

// buildPackagesByLayer organizes packages by architectural layer
func buildPackagesByLayer(files []FileWithAPI) LayerPackages {
	packageMap := make(map[string]*PackageIndexInfo)

	// Build package information from files
	for _, file := range files {
		pkgName := file.GetPackage()
		if pkgName == "" {
			continue
		}

		if _, exists := packageMap[pkgName]; !exists {
			packageMap[pkgName] = &PackageIndexInfo{
				Name:       pkgName,
				KeyExports: []string{},
				Dependencies: []string{},
			}
		}

		pkg := packageMap[pkgName]
		pkg.FileCount++

		// Collect unique key exports (types and important functions)
		for _, decl := range file.GetExportedDecls() {
			pkg.ExportCount++
			// Keep first 3 exports as key exports
			if len(pkg.KeyExports) < 3 {
				pkg.KeyExports = append(pkg.KeyExports, decl.GetName())
			}
		}
	}

	// Organize by layer
	result := LayerPackages{
		CmdPackages:      []PackageIndexInfo{},
		PkgPackages:      []PackageIndexInfo{},
		InternalPackages: []PackageIndexInfo{},
	}

	pkgNames := make([]string, 0, len(packageMap))
	for name := range packageMap {
		pkgNames = append(pkgNames, name)
	}
	sort.Strings(pkgNames)

	for _, name := range pkgNames {
		pkg := packageMap[name]
		if strings.HasPrefix(name, "main") || strings.HasPrefix(name, "cmd/") {
			result.CmdPackages = append(result.CmdPackages, *pkg)
		} else if strings.HasPrefix(name, "pkg/") {
			result.PkgPackages = append(result.PkgPackages, *pkg)
		} else if strings.HasPrefix(name, "internal/") {
			result.InternalPackages = append(result.InternalPackages, *pkg)
		}
	}

	// Sort each layer by name
	sort.Slice(result.CmdPackages, func(i, j int) bool {
		return result.CmdPackages[i].Name < result.CmdPackages[j].Name
	})
	sort.Slice(result.PkgPackages, func(i, j int) bool {
		return result.PkgPackages[i].Name < result.PkgPackages[j].Name
	})
	sort.Slice(result.InternalPackages, func(i, j int) bool {
		return result.InternalPackages[i].Name < result.InternalPackages[j].Name
	})

	return result
}

// formatPackageEntry formats a single package entry in the index
func formatPackageEntry(sb *strings.Builder, pkg PackageIndexInfo) {
	// Package name and basic info
	sb.WriteString(fmt.Sprintf("- **%s**\n", pkg.Name))
	sb.WriteString(fmt.Sprintf("  - Files: %d | Exports: %d\n", pkg.FileCount, pkg.ExportCount))

	// Key exports
	if len(pkg.KeyExports) > 0 {
		sb.WriteString(fmt.Sprintf("  - Key exports: %s\n", strings.Join(pkg.KeyExports, ", ")))
	}

	sb.WriteString("\n")
}
