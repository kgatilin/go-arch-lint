package output

import (
	"fmt"
	"sort"
	"strings"
	"time"
)

// FileDetail contains information about a single file
type FileDetail struct {
	Name      string // File name (e.g., "linter.go")
	LineCount int    // Number of lines in the file
}

// PackageIndexInfo contains summary information about a package
type PackageIndexInfo struct {
	Name         string
	Path         string       // Directory path for the package (e.g., "pkg/linter")
	FileCount    int
	Files        []FileDetail // List of files with line counts
	ExportCount  int
	KeyExports   []string // Top 3-4 important types/functions
	Dependencies []string // Just package names
}

// LayerPackages organizes packages by architectural layer
type LayerPackages struct {
	CmdPackages      []PackageIndexInfo
	PkgPackages      []PackageIndexInfo
	InternalPackages []PackageIndexInfo
}

// GenerateIndexDocumentation creates a lightweight architecture index
func GenerateIndexDocumentation(doc FullDocumentation) string {
	var sb strings.Builder

	// Header
	sb.WriteString("# Project Architecture Index\n\n")
	sb.WriteString(fmt.Sprintf("**Generated by go-arch-lint on %s**\n\n", time.Now().Format("2006-01-02")))
	sb.WriteString("*Quick architecture reference. Use package-specific Details commands for comprehensive information.*\n\n")

	// Quick Reference
	sb.WriteString("## Quick Reference\n\n")
	statusStr := "✓ 0 violations"
	if doc.ViolationCount > 0 {
		statusStr = fmt.Sprintf("✗ %d violation(s)", doc.ViolationCount)
	}
	sb.WriteString("- **Module**: (detected from go.mod)\n")
	sb.WriteString(fmt.Sprintf("- **Status**: %s\n", statusStr))
	sb.WriteString(fmt.Sprintf("- **Packages**: %d\n", doc.PackageCount))
	sb.WriteString(fmt.Sprintf("- **Files**: %d\n\n", doc.FileCount))

	// Architecture Summary
	sb.WriteString("## Architecture Summary\n\n")
	if len(doc.Structure.RequiredDirectories) > 0 {
		sb.WriteString("Project uses strict layered architecture:\n\n")
		for dirPath, description := range doc.Structure.RequiredDirectories {
			if allowed, exists := doc.Rules.DirectoriesImport[dirPath]; exists {
				allowedStr := "none (isolated)"
				if len(allowed) > 0 {
					allowedStr = strings.Join(allowed, ", ")
				}
				sb.WriteString(fmt.Sprintf("- **%s** - %s (imports: %s)\n", dirPath, description, allowedStr))
			}
		}
		sb.WriteString("\n")
	}

	// Architectural Rules (CRITICAL per mentor feedback)
	sb.WriteString("## Architectural Rules\n\n")
	sb.WriteString("**Layer Dependencies:**\n\n")
	for dir, allowed := range doc.Rules.DirectoriesImport {
		if len(allowed) == 0 {
			sb.WriteString(fmt.Sprintf("- `%s` → `[]` (complete isolation)\n", dir))
		} else {
			sb.WriteString(fmt.Sprintf("- `%s` → `[%s]`\n", dir, strings.Join(allowed, ", ")))
		}
	}
	sb.WriteString("\n")

	if !doc.Structure.AllowOtherDirectories {
		sb.WriteString("**Strict Mode**: Only required directories are allowed\n\n")
	}

	// Dependency Graph (package-level, non-detailed)
	sb.WriteString("## Dependency Graph\n\n")
	sb.WriteString("Package-level dependencies (local dependencies only):\n\n")

	pkgDeps := buildPackageDependencies(doc.Graph)

	// Sort package names for consistent output
	pkgNames := make([]string, 0, len(pkgDeps))
	for pkgPath := range pkgDeps {
		pkgNames = append(pkgNames, pkgPath)
	}
	sort.Strings(pkgNames)

	if len(pkgNames) == 0 {
		sb.WriteString("*No packages found*\n\n")
	} else {
		for _, pkgPath := range pkgNames {
			deps := pkgDeps[pkgPath]
			if len(deps.LocalDeps) == 0 {
				sb.WriteString(fmt.Sprintf("- **%s** → *(no local dependencies)*\n", pkgPath))
			} else {
				// Sort dependencies for consistent output
				sortedDeps := make([]string, len(deps.LocalDeps))
				copy(sortedDeps, deps.LocalDeps)
				sort.Strings(sortedDeps)
				sb.WriteString(fmt.Sprintf("- **%s** → %s\n", pkgPath, strings.Join(sortedDeps, ", ")))
			}
		}
		sb.WriteString("\n")
	}

	// Build package index by layer
	packagesByLayer := buildPackagesByLayer(doc.Files)

	// Package Directory
	sb.WriteString("## Package Directory\n\n")

	if len(packagesByLayer.CmdPackages) > 0 {
		sb.WriteString("### cmd (Application Entry Points)\n\n")
		for _, pkg := range packagesByLayer.CmdPackages {
			formatPackageEntry(&sb, pkg)
		}
		sb.WriteString("\n")
	}

	if len(packagesByLayer.PkgPackages) > 0 {
		sb.WriteString("### pkg (Public APIs)\n\n")
		for _, pkg := range packagesByLayer.PkgPackages {
			formatPackageEntry(&sb, pkg)
		}
		sb.WriteString("\n")
	}

	if len(packagesByLayer.InternalPackages) > 0 {
		sb.WriteString("### internal (Isolated Primitives)\n\n")
		for _, pkg := range packagesByLayer.InternalPackages {
			formatPackageEntry(&sb, pkg)
		}
		sb.WriteString("\n")
	}

	// Agent Guidance
	sb.WriteString("## Agent Guidance\n\n")
	sb.WriteString("To get detailed information about specific packages:\n\n")
	sb.WriteString("**Per-package details**:\n")
	sb.WriteString("- Each package above has a **Details** command to get full information\n")
	sb.WriteString("- Example: `go-arch-lint -format=package pkg/linter`\n")
	sb.WriteString("- Shows: full API, dependencies, exported types/functions for that package\n\n")
	sb.WriteString("**Project-wide information**:\n")
	sb.WriteString("- Public API for all packages: `./go-arch-lint -format=api .`\n")
	sb.WriteString("- Dependency graph: `./go-arch-lint -format=markdown .`\n")
	sb.WriteString("- Method-level dependencies: `./go-arch-lint -detailed -format=markdown .`\n")
	sb.WriteString("- Check violations: `./go-arch-lint .`\n\n")
	sb.WriteString("**Common workflows**:\n")
	sb.WriteString("- Understanding a package → Find it below, run the Details command\n")
	sb.WriteString("- Adding new feature → Review architectural rules above, check layer constraints\n")
	sb.WriteString("- Checking violations → Run `./go-arch-lint .` to see current issues with guidance\n\n")

	// Statistics
	sb.WriteString("## Statistics\n\n")
	sb.WriteString(fmt.Sprintf("- **Total Files**: %d\n", doc.FileCount))
	sb.WriteString(fmt.Sprintf("- **Total Packages**: %d\n", doc.PackageCount))
	sb.WriteString(fmt.Sprintf("- **Violations**: %d\n", doc.ViolationCount))

	// Count external dependencies
	externalDepsSet := make(map[string]bool)
	for _, node := range doc.Graph.GetNodes() {
		for _, dep := range node.GetDependencies() {
			if !dep.IsLocalDep() {
				externalDepsSet[dep.GetImportPath()] = true
			}
		}
	}
	sb.WriteString(fmt.Sprintf("- **External Dependencies**: %d\n\n", len(externalDepsSet)))

	sb.WriteString("---\n\n")
	sb.WriteString("*Use the package-specific Details commands above to get comprehensive information about each package.*\n")
	sb.WriteString("*Run `./go-arch-lint docs` to regenerate this index.*\n")

	return sb.String()
}

// buildPackagesByLayer organizes packages by architectural layer
func buildPackagesByLayer(files []FileWithAPI) LayerPackages {
	packageMap := make(map[string]*PackageIndexInfo)

	// Build package information from files
	for _, file := range files {
		pkgName := file.GetPackage()
		relPath := file.GetRelPath()
		if pkgName == "" {
			continue
		}

		// Extract directory path from file path (e.g., "pkg/linter/linter.go" → "pkg/linter")
		pkgPath := relPath
		if idx := strings.LastIndex(relPath, "/"); idx >= 0 {
			pkgPath = relPath[:idx]
		} else {
			// File in root directory
			pkgPath = "."
		}

		// Use package path as the key to group files by directory
		if _, exists := packageMap[pkgPath]; !exists {
			packageMap[pkgPath] = &PackageIndexInfo{
				Name:         pkgName,
				Path:         pkgPath,
				Files:        []FileDetail{},
				KeyExports:   []string{},
				Dependencies: []string{},
			}
		}

		pkg := packageMap[pkgPath]

		// Skip test files when counting files and collecting exports
		isTestFile := strings.HasSuffix(relPath, "_test.go")

		// Only count and track non-test files
		if !isTestFile {
			pkg.FileCount++
			// Extract file name from path
			fileName := relPath
			if idx := strings.LastIndex(relPath, "/"); idx >= 0 {
				fileName = relPath[idx+1:]
			}
			pkg.Files = append(pkg.Files, FileDetail{
				Name:      fileName,
				LineCount: file.GetLineCount(),
			})
		}

		// Collect unique key exports (types and important functions)
		for _, decl := range file.GetExportedDecls() {
			isTestExport := strings.HasPrefix(decl.GetName(), "Test") || strings.HasPrefix(decl.GetName(), "Benchmark")

			// Only count non-test exports
			if !isTestFile && !isTestExport {
				pkg.ExportCount++

				// Keep first 3 exports as key exports
				if len(pkg.KeyExports) < 3 {
					pkg.KeyExports = append(pkg.KeyExports, decl.GetName())
				}
			}
		}
	}

	// Organize by layer (using Path not Name)
	result := LayerPackages{
		CmdPackages:      []PackageIndexInfo{},
		PkgPackages:      []PackageIndexInfo{},
		InternalPackages: []PackageIndexInfo{},
	}

	pkgPaths := make([]string, 0, len(packageMap))
	for path := range packageMap {
		pkgPaths = append(pkgPaths, path)
	}
	sort.Strings(pkgPaths)

	for _, path := range pkgPaths {
		pkg := packageMap[path]
		if strings.HasPrefix(path, "cmd") {
			result.CmdPackages = append(result.CmdPackages, *pkg)
		} else if strings.HasPrefix(path, "pkg") {
			result.PkgPackages = append(result.PkgPackages, *pkg)
		} else if strings.HasPrefix(path, "internal") {
			result.InternalPackages = append(result.InternalPackages, *pkg)
		}
	}

	// Sort each layer by path
	sort.Slice(result.CmdPackages, func(i, j int) bool {
		return result.CmdPackages[i].Path < result.CmdPackages[j].Path
	})
	sort.Slice(result.PkgPackages, func(i, j int) bool {
		return result.PkgPackages[i].Path < result.PkgPackages[j].Path
	})
	sort.Slice(result.InternalPackages, func(i, j int) bool {
		return result.InternalPackages[i].Path < result.InternalPackages[j].Path
	})

	return result
}

// formatPackageEntry formats a single package entry in the index
func formatPackageEntry(sb *strings.Builder, pkg PackageIndexInfo) {
	// Package name and path
	sb.WriteString(fmt.Sprintf("- **%s** (`%s`)\n", pkg.Name, pkg.Path))

	// Format files with line counts
	if len(pkg.Files) > 0 {
		// Sort files by name for consistent output
		sort.Slice(pkg.Files, func(i, j int) bool {
			return pkg.Files[i].Name < pkg.Files[j].Name
		})

		fileDetails := make([]string, len(pkg.Files))
		for i, file := range pkg.Files {
			fileDetails[i] = fmt.Sprintf("%s: %d", file.Name, file.LineCount)
		}
		sb.WriteString(fmt.Sprintf("  - Files: %d (%s) | Exports: %d\n", pkg.FileCount, strings.Join(fileDetails, ", "), pkg.ExportCount))
	} else {
		sb.WriteString(fmt.Sprintf("  - Files: %d | Exports: %d\n", pkg.FileCount, pkg.ExportCount))
	}

	// Key exports
	if len(pkg.KeyExports) > 0 {
		sb.WriteString(fmt.Sprintf("  - Key exports: %s\n", strings.Join(pkg.KeyExports, ", ")))
	}

	// Command to get detailed info
	sb.WriteString(fmt.Sprintf("  - **Details**: `go-arch-lint -format=package %s`\n", pkg.Path))

	sb.WriteString("\n")
}

// PackageDependencies holds dependency information for a package
type PackageDependencies struct {
	LocalDeps    []string // Local package dependencies (deduplicated)
	ExternalDeps []string // External dependencies (deduplicated)
}

// buildPackageDependencies creates a package-level dependency map from the graph
func buildPackageDependencies(graph Graph) map[string]PackageDependencies {
	// Map package path to its dependencies
	pkgDepsMap := make(map[string]map[string]bool) // package -> set of local deps
	pkgExternalMap := make(map[string]map[string]bool) // package -> set of external deps

	// Process all file nodes
	for _, node := range graph.GetNodes() {
		pkgPath := extractPackagePath(node.GetRelPath())
		if pkgPath == "" {
			continue
		}

		// Initialize maps if needed
		if pkgDepsMap[pkgPath] == nil {
			pkgDepsMap[pkgPath] = make(map[string]bool)
		}
		if pkgExternalMap[pkgPath] == nil {
			pkgExternalMap[pkgPath] = make(map[string]bool)
		}

		// Collect dependencies from this file
		for _, dep := range node.GetDependencies() {
			if dep.IsLocalDep() {
				depPkgPath := dep.GetLocalPath()
				// Don't add self-dependencies
				if depPkgPath != pkgPath {
					pkgDepsMap[pkgPath][depPkgPath] = true
				}
			} else if !isStdLib(dep.GetImportPath()) {
				pkgExternalMap[pkgPath][dep.GetImportPath()] = true
			}
		}
	}

	// Convert to final format
	result := make(map[string]PackageDependencies)
	for pkgPath, depsSet := range pkgDepsMap {
		deps := PackageDependencies{
			LocalDeps:    make([]string, 0, len(depsSet)),
			ExternalDeps: make([]string, 0),
		}

		// Convert set to slice
		for dep := range depsSet {
			deps.LocalDeps = append(deps.LocalDeps, dep)
		}

		// Add external deps if any
		if externalSet, exists := pkgExternalMap[pkgPath]; exists {
			for extDep := range externalSet {
				deps.ExternalDeps = append(deps.ExternalDeps, extDep)
			}
		}

		result[pkgPath] = deps
	}

	return result
}

// extractPackagePath extracts the package directory path from a file path
// e.g., "pkg/linter/linter.go" → "pkg/linter"
// e.g., "main.go" → "."
func extractPackagePath(filePath string) string {
	if idx := strings.LastIndex(filePath, "/"); idx >= 0 {
		return filePath[:idx]
	}
	return "."
}
